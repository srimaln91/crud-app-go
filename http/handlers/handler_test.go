package handlers

import (
	"bytes"
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"reflect"
	"testing"

	"github.com/srimaln91/crud-app-go/core/entities"
	"github.com/srimaln91/crud-app-go/externals/repositories"
	"github.com/srimaln91/crud-app-go/log"
	"github.com/srimaln91/crud-app-go/testutil"
)

var eventRepository = repositories.NewEventRepositoryMock()
var logger, _ = log.NewLogger(log.DEBUG)

type responseWrapper struct {
	Data    entities.Task `json:"data"`
	Status  string        `json:"status"`
	Message string        `json:"message"`
}

func TestAddTask(t *testing.T) {

	task := testutil.GenerateFakeTasks(1)[0]
	// Set ID as empty as it is an autogenerated field
	task.ID = ""

	JSONbytes, err := json.Marshal(task)
	if err != nil {
		t.Error(err)
		return
	}

	var bytes = bytes.NewBuffer(JSONbytes)

	req := httptest.NewRequest(http.MethodPost, "/api/tasks", bytes)
	w := httptest.NewRecorder()

	h := NewHttpHandler(eventRepository, logger)
	h.AddTask(w, req)

	res := w.Result()

	if res.StatusCode != http.StatusCreated {
		t.Error("invalid response code")
		return
	}

	var responseData responseWrapper
	responseBytes, err := ioutil.ReadAll(res.Body)
	if err != nil {
		t.Error(err)
		return
	}

	err = json.Unmarshal(responseBytes, &responseData)
	if err != nil {
		t.Error(err)
		return
	}

	eventID := responseData.Data.ID

	// setting up id as empty since it is auto generated
	responseData.Data.ID = ""
	if !reflect.DeepEqual(responseData.Data, task) {
		t.Error("invalid response received")
	}

	// The created event should be in data store
	storeEvent, err := eventRepository.Get(context.Background(), eventID)
	if err != nil {
		t.Error(err)
		return
	}

	if storeEvent == nil {
		t.Error("null value found in store. HTTP transaction failed")
		return
	}
}
